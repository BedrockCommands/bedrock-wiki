import{_ as i}from"./chunks/7.d3b49dbe.js";import{_ as t,c as l,a as n,w as a,e,r,o as c,d as o}from"./404.md.eebc8d69.js";const d="/assets/images/commands/commandBlockChain/5.png",w=JSON.parse('{"title":"Movement Detections","description":"","frontmatter":{"title":"Movement Detections","category":"Techniques","mention":["BedrockCommands","zheaEvyline"]},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"is_moving","slug":"is-moving","link":"#is-moving","children":[{"level":3,"title":"Commands","slug":"commands","link":"#commands","children":[]},{"level":3,"title":"States","slug":"states","link":"#states","children":[]},{"level":3,"title":"Purpose Of Each Command","slug":"purpose-of-each-command","link":"#purpose-of-each-command","children":[]}]},{"level":2,"title":"is_sneaking","slug":"is-sneaking","link":"#is-sneaking","children":[{"level":3,"title":"Commands","slug":"commands-1","link":"#commands-1","children":[]},{"level":3,"title":"States","slug":"states-1","link":"#states-1","children":[]},{"level":3,"title":"Purpose Of Each Command","slug":"purpose-of-each-command-1","link":"#purpose-of-each-command-1","children":[]}]}],"relativePath":"commands/states.md"}'),m={name:"commands/states.md"},p=e('<h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h2><p><a href="https://discord.gg/SYstTYx5G5" target="_blank" rel="noreferrer">Sourced By Bedrock Commands Community Discord</a></p><p>These command-techniques allow you to detect certain player/entity &#39;states&#39; and subsequently execute your desired commands.</p><blockquote><p>Note: for a more performant and high-accuracy approach, refer to <a href="/animation-controllers/animation-controllers-intro.html">Animation Controllers</a></p></blockquote><h2 id="is-moving" tabindex="-1">is_moving <a class="header-anchor" href="#is-moving" aria-hidden="true">#</a></h2><p>This technique allows you to detect when your target is/isn&#39;t moving.</p><blockquote><p>Note: It does not account for movement while the spyglass is zoomed in or when Slowness Level 6 or higher is in effect.</p></blockquote><h3 id="commands" tabindex="-1">Commands <a class="header-anchor" href="#commands" aria-hidden="true">#</a></h3><ul><li>Make sure you add the <code>is_moving</code> scoreboard objective: <ul><li><code>/scoreboard objectives add is_moving dummy</code></li></ul></li></ul>',9),u=e(`<div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki"><code><span class="line"><span style="color:#C3E88D;">/execute as @a at @s positioned ~~10000~ if entity @e [type=leash_knot, r=0.1252] run scoreboard players set @s is_moving 0</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a at @s positioned ~~10000~ unless entity @e [type=leash_knot, r=0.1252] run scoreboard players add @s is_moving 1</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @e [type=leash_knot] at @s unless entity @s [y=-80, dy=9974] run kill @s</span></span>
<span class="line"><span style="color:#C3E88D;">/execute at @a positioned ~~10000~ run summon leash_knot ~~~</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">#Your Commands Here (example)</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_moving=0}] run say I&#39;m not moving</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_moving=1}] run say I started moving</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_moving=2..}] run say I&#39;m still moving</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="`+i+'" alt="commandBlockChain7"></p><p>It is a requirement to follow this same sequence and properly apply the <code>scores</code> selector argument as shown for your desired commands.</p><h3 id="states" tabindex="-1">States <a class="header-anchor" href="#states" aria-hidden="true">#</a></h3><ul><li><strong><code>is_moving=0</code></strong> target is <em>not</em> moving. (used for repeating actions)</li><li><strong><code>is_moving=1</code></strong> target started moving. (used for &#39;trigger&#39; actions)</li><li><strong><code>is_moving=2..</code></strong> target is still moving. (used for repeating actions)</li></ul><h3 id="purpose-of-each-command" tabindex="-1">Purpose Of Each Command <a class="header-anchor" href="#purpose-of-each-command" aria-hidden="true">#</a></h3><ul><li><strong>Command 1:</strong> If there is a Leash Knot above them, it means they have not moved from their &quot;point&quot; from the previous game-tick. Marking them as <em>not</em> moving (0) <ul><li>Leash Knot is a Vanilla entity with anti-gravity behaviour which serves as an optimization for this system.</li></ul></li><li><strong>Command 2:</strong> If there <em>isn&#39;t</em> a Leash Knot above them, it means they have displaced from their &quot;point&quot; from the previous game-tick. Markinh them as <em>moving</em> (1) by adding a score. <ul><li>The score will keep incrementing if they keep moving without pause. Allowing us to use single-execution commands each time they start moving.</li></ul></li><li><strong>Command 3:</strong> We need to delete all previous &quot;points&quot; (kill old Leash Knots) to minimise entity lag. We will also avoid affecting any Leash Knots below the ~10000 height not involved in this system. <ul><li>we are using the volume filter instead of a simple name filter to do that, because Leash Knots cannot be named.</li></ul></li><li><strong>Command 4:</strong> We will summon a new Leash Knot ~10000 blocks above the player to mark the point they are currently at which we will testfor in command 1 &amp; 2, in the next game tick. (when this command block chain loops/repeats)</li><li><strong>Command 5, 6, 7:</strong> These are example commands (for each state) which can be modified / expanded.</li></ul><h2 id="is-sneaking" tabindex="-1">is_sneaking <a class="header-anchor" href="#is-sneaking" aria-hidden="true">#</a></h2><p>This technique allows you to detect when your target is/is&#39;nt sneaking.</p><p>Thanks to the introduction of Short Sneaking parity in 1.20.10 which reduces the player hitbox to 1.5 blocks when sneaking, making a proper sneak-detection using just commands is now possible which previously required add-on assistance.</p><h3 id="commands-1" tabindex="-1">Commands <a class="header-anchor" href="#commands-1" aria-hidden="true">#</a></h3><ul><li>Make sure you add the <code>is_sneaking</code> scoreboard objective: <ul><li><code>/scoreboard objectives add is_sneaking dummy</code></li></ul></li></ul>',12),h=e(`<div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki"><code><span class="line"><span style="color:#C3E88D;">/execute as @a at @s anchored eyes positioned ~~-1.6~ if entity @s [r=0.1] run scoreboard players set @s is_sneaking 0</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a at @s anchored eyes positioned ~~-1.6~ unless entity @s [r=0.1] run scoreboard players add @s is_sneaking 1</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">#Your Commands Here (example)</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_sneaking=0}] run say I&#39;m not sneaking</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_sneaking=1}] run say I started sneaking</span></span>
<span class="line"><span style="color:#C3E88D;">/execute as @a [scores={is_sneaking=2..}] run say I&#39;m still sneaking</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="`+d+'" alt="commandBlockChain5"></p><p>It is a requirement to follow this same sequence and properly apply the <code>scores</code> selector argument as shown for your desired commands.</p><h3 id="states-1" tabindex="-1">States <a class="header-anchor" href="#states-1" aria-hidden="true">#</a></h3><ul><li><strong><code>is_sneaking=0</code></strong> player is <em>not</em> sneaking. (used for repeating actions)</li><li><strong><code>is_sneaking=1</code></strong> player started sneaking. (used for &#39;trigger&#39; actions)</li><li><strong><code>is_sneaking=2..</code></strong> player is still sneaking. (used for repeating actions)</li></ul><p>With the introduction of Short Sneaking parity in 1.20.10 which reduces the player hitbox to 1.5 blocks when sneaking, we can now make sneak-detection using just commands which was previously not possible without add-on assistance.</p><h3 id="purpose-of-each-command-1" tabindex="-1">Purpose Of Each Command <a class="header-anchor" href="#purpose-of-each-command-1" aria-hidden="true">#</a></h3><p><strong>Command 1/2 Breakdown:</strong></p><ul><li><code>as @a</code><ul><li>sets the execution target as all players.</li></ul></li><li><code>at @s</code><ul><li>sets the execution position to the target.</li></ul></li><li><code>anchored eyes</code><ul><li>brings the execution position up to the target&#39;s eye level.</li></ul></li><li><code>positioned ~~-1.6~</code><ul><li>brings the execution position 1.6 blocks below the target&#39;s eye level.</li></ul></li><li><code>if/unless entity @s [r=0.1]</code><ul><li>adds the condition to test for the target&#39;s hitbox at that execution position/point.</li><li>if <em>(presence)</em> indicating the target&#39;s hitbox is taller than 1.5 blocks. Standing, <em>not</em> sneaking (0)</li><li>unless <em>(lack of)</em> indicating the target&#39;s hitbox is shorter than 1.6 blocks. Sneaking (1)</li></ul></li></ul><p><strong>Command 4, 5, 6:</strong> These are example commands (for each state) which can be modified / expanded.</p>',10);function g(b,y,_,k,f,v){const s=r("CodeHeader");return c(),l("div",null,[p,n(s,null,{default:a(()=>[o("BP/functions/states/is_moving.mcfunction")]),_:1}),u,n(s,null,{default:a(()=>[o("BP/functions/states/is_sneaking.mcfunction")]),_:1}),h])}const T=t(m,[["render",g]]);export{w as __pageData,T as default};
