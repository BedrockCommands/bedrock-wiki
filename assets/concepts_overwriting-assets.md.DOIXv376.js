import{_ as a,c as n,b as e,a as o,U as i,T as t,o as r,r as l}from"./chunks/framework.KjOEH70y.js";const T=JSON.parse('{"title":"Overwriting Assets","description":"Overwriting assets explained.","frontmatter":{"title":"Overwriting Assets","tags":["intermediate"],"mentions":["SirLich","MedicalJewel105","Luthorius","SmokeyStack"],"description":"Overwriting assets explained."},"headers":[],"relativePath":"concepts/overwriting-assets.md","filePath":"concepts/overwriting-assets.md","lastUpdated":1724083202000}'),h={name:"concepts/overwriting-assets.md"},c=i('<h2 id="add-on-layering" tabindex="-1">Add-on Layering <a class="header-anchor" href="#add-on-layering" aria-label="Permalink to &quot;Add-on Layering&quot;">​</a></h2><p>The add-on system is built layer by layer, where each pack is added <em>on top</em> of the ones before it. Even if you only have a single pack added, there is an implicit <em>vanilla</em> pack which is always added. When you add custom content, this content will have full access to all vanilla files.</p><h3 id="accessing-vanilla-files" tabindex="-1">Accessing Vanilla Files <a class="header-anchor" href="#accessing-vanilla-files" aria-label="Permalink to &quot;Accessing Vanilla Files&quot;">​</a></h3><p>This layered structure is very useful, because it allows us to access the files inside of vanilla, without copy/pasting them into our add-on. For example you can access <code>blocks/stone.png</code> without moving it into your add-on! Just set it as the texture for your custom entity - it will work out of the box. This is particularly useful for things like models, or render controllers, or sounds.</p><p>If the vanilla assets change, for example if <a href="https://twitter.com/JasperBoerstra?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor" target="_blank" rel="noreferrer">JAPPA</a> updates the stone texture, your add-on will also receive the update, since you are relying on the actual dynamic, vanilla resources.</p><p>You should try to use this system of layering as often as you can. If you don&#39;t <em>need</em> to copy/paste something into your add-on, don&#39;t.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>It is never OK to make an add-on inside of a copy of the vanilla resource/behavior pack. This will make the download for your add-on incredibly huge, and will reduce performance. Always begin with a blank add-on, then copy/paste the files you want to overwrite.</p></div><h2 id="overwriting-assets" tabindex="-1">Overwriting Assets <a class="header-anchor" href="#overwriting-assets" aria-label="Permalink to &quot;Overwriting Assets&quot;">​</a></h2><p>Pack Layering also allows us to overwrite vanilla assets, by <em>overwriting</em> them with a file that shares the same path, or the same identifier. Our new file will replace the one being used in vanilla, allowing us to change textures, sounds, entity behavior, etc.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Different resources have different methods of overwriting, so be careful to use the right method for each type!</p></div><h3 id="overwriting-by-path" tabindex="-1">Overwriting by Path <a class="header-anchor" href="#overwriting-by-path" aria-label="Permalink to &quot;Overwriting by Path&quot;">​</a></h3><p>Assets that are referenced by <em>path</em>, and do <em>not have an identifier</em> can be overwritten by simply placing a new asset into the same path. The following can be overwritten in this way:</p><ul><li>Functions</li><li>Loot tables</li><li>Textures</li><li>Sounds</li><li>Trade Tables</li></ul><p>When you overwrite these files, the overwriting is absolute: The new asset will fully replace the old asset.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>Example</strong>: If you would like to replace the redstone ore texture, simply place a new file at <code>textures/blocks/redstone_ore.png</code>.</p></div><h3 id="overwriting-by-identifier" tabindex="-1">Overwriting by Identifier <a class="header-anchor" href="#overwriting-by-identifier" aria-label="Permalink to &quot;Overwriting by Identifier&quot;">​</a></h3><p>Many assets are defined not by their name, but by their identifier! To overwrite these assets, simply create a new file that shares the same identifier, regardless of file-path. The following can be overwritten in this way:</p><ul><li>BP Entities</li><li>RP Entities</li><li>Animations</li><li>Models</li><li>Animation Controllers</li><li>Spawn Rules</li><li>Recipes</li><li>Particles</li><li>Render Controllers</li></ul><p>When you overwrite these files, the overwriting is absolute: The new asset will fully replace the old asset.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>Example</strong>: If you would like to make Ghasts have higher health, simply create a new BP entity with the <code>minecraft:ghast</code> identifier, and all the behaviors required to make the ghast function.</p><p>Remember, entity files do not merge together, so you will first need to copy/paste the entire BP Ghast file, and <em>then</em> edit the health. Simply creating a <code>minecraft:ghast</code> with a high health component inside will not work.</p></div><h3 id="overwriting-via-reference-file" tabindex="-1">Overwriting via Reference File <a class="header-anchor" href="#overwriting-via-reference-file" aria-label="Permalink to &quot;Overwriting via Reference File&quot;">​</a></h3><p>Many assets can also be registered into some kind of &quot;registration system&quot; file. These files are interesting, because unlike the other asset types, they are <em>merged together</em> instead of <em>overwritten</em>. This means that when you define these files, you do not need to copy from the vanilla resources. You can simply start with a blank file, and then overwrite the specific definitions you want.</p><p>The following files work in this way:</p><ul><li>All UI files</li><li><a href="/concepts/text-and-translations.html">All language files</a></li><li><code>item_textures.json</code></li><li><code>flipbook_textures.json</code></li><li><code>terrain_textures.json</code></li><li><code>sounds.json</code></li><li><code>music_definitions.json</code></li><li><code>sound_definitions.json</code></li></ul>',24),d={class:"tip custom-block"},p=e("p",{class:"custom-block-title"},"TIP",-1),u=e("p",null,[e("strong",null,"Example:"),t(" Lets say you want to override the "),e("code",null,"sugar"),t(" texture, using the reference files. You can do so by creating a new "),e("code",null,"item_textures.json"),t(", with the following contents:")],-1),m=i(`<div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;resource_pack_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vanilla&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;texture_data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		&quot;sugar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">			&quot;textures&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;textures/path/to/my/sugar&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>This <em>definition</em> will be merged with the vanilla <code>item_textures.json</code>, and will override the short-name <code>sugar</code>. When the vanilla item accesses this short-name, it will get a reference to your custom texture path, instead of the actual texture path to sugar.</p>`,2),g=i('<h2 id="overwriting-dangers" tabindex="-1">Overwriting Dangers <a class="header-anchor" href="#overwriting-dangers" aria-label="Permalink to &quot;Overwriting Dangers&quot;">​</a></h2><p>Since add-ons mostly <em>overwrite</em> each other rather than <em>merge</em>, it can be very difficult to get two incompatible add-ons to work together. For example, if you try to combine two add-ons that overwrite the creeper behavior (for example, one makes them very fast, and one makes them very large) the add-on you have applied <em>second</em> will overwrite the first.</p><p>This is mostly a problem with <code>player.json</code> (in either the RP or the BP), since this file is often used for gameplay purposes.</p><h2 id="things-that-cannot-be-overwritten" tabindex="-1">Things that Cannot be Overwritten <a class="header-anchor" href="#things-that-cannot-be-overwritten" aria-label="Permalink to &quot;Things that Cannot be Overwritten&quot;">​</a></h2><p>Not everything can be overwritten, the following is a list of things that cannot be overwritten using any of the described methods:</p><ul><li>Vanilla items (Not all)</li><li>Vanilla blocks</li><li>Vanilla fogs (create a fog with another namespace and change it everywhere it is used)</li></ul>',6);function f(w,y,v,b,k,_){const s=l("CodeHeader");return r(),n("div",null,[c,e("div",d,[p,u,o(s),m]),g])}const x=a(h,[["render",f]]);export{T as __pageData,x as default};
